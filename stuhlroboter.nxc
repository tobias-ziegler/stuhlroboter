#define POWER 30
#define LINIENVERFOLGUNG_DREHUNG_LINKS 120
#define LINIENVERFOLGUNG_DREHUNG_RECHTS 240

void sensorenInitialisieren();
void startVorgang();
void bedienungsanleitungAnzeigen();
void aufTastendruckWarten();
void linienVerfolgung(int linienFarbton);
void linksDrehung(int zeitspanne);
void rechtsDrehung(int zeitspanne);
void geradeAusFahren(int zeitspanne);

void turnToColor(int LineColor, int color, int timeTurn90);
void turn(int color, int timeTurn90);
int kalibrierungSW();
long kalibrierung90();

task main() {

	int zeitFuer90GradDrehung;
	//Drive(100);
	int linienFarbton;
	int stuhlFarbe;

	//Kalibrierung
	zeitFuer90GradDrehung = kalibrierung90();
	linienFarbton = kalibrierungSW();

	//Start
	sensorenInitialisieren();
	startVorgang();
	//Farbe einlesen
	stuhlFarbe = Sensor(IN_1);
	Wait(2000);

	//Sortiervorgang
	//Linienverfolgung-Anfang
	linienVerfolgung();
    //Vorfahren zur Mitte
    Drive(1200);
     //Zur Farbe drehen
     turnToColor(LineColor, color, timeTurn90);
     //Liniefahren
     DriveToLineEnd(LineColor);
     turn(color, timeTurn90);
     DriveToLineEnd(LineColor);

}

void sensorenInitialisieren() {
	SetSensorColorFull(IN_1);
	SetSensorLowspeed(IN_2);
	SetSensorLight(IN_3);
	SetSensorTouch(IN_4);
}

void startVorgang() {
	bedienungsanleitungAnzeigen();
	aufTastendruckWarten();
	//Konsole löschen
	ClearScreen();
	//Ton ausgeben
	PlaySound(SOUND_DOUBLE_BEEP);
}

void bedienungsanleitungAnzeigen() {
	TextOut(5, LCD_LINE1, "Drücken Sie den Knopf, um den Sortiervorgang zu starten.");
}

void aufTastendruckWarten() {
	while(true) {
		if(Sensor(IN_4) == 1) {
			break;
		}
	}
}

//TODO: tidy up and display error
void linienVerfolgung(int linienFarbton) {
	while(true) {
		if(Sensor(IN_3)  <= linienFarbton) {
			OnFwd(OUT_AB,POWER);
		} else {
			//Links
			linksDrehung(LINIENVERFOLGUNG_DREHUNG_LINKS);
			//Überprüfung
			if(Sensor(IN_3) > linienFarbton) {
				//Rechts
				rechtsDrehung(LINIENVERFOLGUNG_DREHUNG_RECHTS);
				if(Sensor(IN_3) > linienFarbton) {
					//Links
					linksDrehung(LINIENVERFOLGUNG_DREHUNG_LINKS);
					break;
				}
			}
		}
	}
}

void linksDrehung(int zeitspanne) {
	OnFwd(OUT_B,POWER);
	OnRev(OUT_A,POWER);
	Wait(zeitspanne);
	Off(OUT_AB);
}

void rechtsDrehung(int zeitspanne) {
	OnFwd(OUT_A,POWER);
	OnRev(OUT_B,POWER);
	Wait(zeitspanne);
	Off(OUT_AB);
}

void geradeAusFahren(int zeitspanne) {
	OnFwd(OUT_AB, POWER);
	Wait(zeitspanne);
	Off(OUT_AB);
}

void turnToColor(int LineColor, int color, int timeTurn90) {
     switch(color) {
         //Schwarz
         case 1: {
             //Rechtsdrehung
             OnFwd(OUT_A,POWER);
             OnRev(OUT_B,POWER);
             Wait(timeTurn90);
             Off(OUT_AB);
         }
     }
}

void turn(int color, int timeTurn90) {
    switch(color) {
        case 1: {
             Drive(400);
             //Linksdrehung
             OnFwd(OUT_B,POWER);
             OnRev(OUT_A,POWER);
             Wait(timeTurn90);
             Off(OUT_AB);
        }
    }
}

int kalibrierungSW(void)
	//Funktion zur Ermittlung des Schwarzwertes
	//der Linienkante durch Berechnung des Durch-
	//schnittes aus Minimal-(schwarz) und Maximalwert(weiß)
	//Funktion hat eigene "POWER" (=50)
	//die auf "Dreh-Zeit" (600/1200) abgestimmt ist.
{
	long end_time;
	long t0 = CurrentTick();
	int iDurchschnitt;
	int imin = 999;
	int imax = -1;
	int iHelligkeitKal=0;
	ClearScreen();
	// Kalibrierung nach links
	TextOut(5,LCD_LINE1, "KALIBRIERUNG LINKS");
  //Motor nach links starten
	OnFwd(OUT_B, 50);
	OnRev(OUT_A, 50);
	while (CurrentTick()-t0 < 990) {
		iHelligkeitKal = Sensor(IN_3);
		if (iHelligkeitKal > imax) {
			imax = iHelligkeitKal;
		} else if (iHelligkeitKal < imin) {
			imin = iHelligkeitKal;
		}
	}
	// Kalibrierung nach rechts
	TextOut(5,LCD_LINE2, "KALIBRIERUNG RECHTS");
	end_time = CurrentTick() + 1200;
	OnFwd(OUT_A, 50);
	OnRev(OUT_B, 50);
	while (CurrentTick() < end_time) {
		iHelligkeitKal = Sensor(IN_3);
		if (iHelligkeitKal > imax) {
			imax = iHelligkeitKal;
		} else if (iHelligkeitKal < imin) {
			imin = iHelligkeitKal;
		}
	}

	//Durchschnitt ausrechnen und anzeigen
	iDurchschnitt = (imin+imax)/2;
	ClearLine(LCD_LINE3);
	TextOut(4,LCD_LINE3, "SW Linienkante:");
	NumOut(65, LCD_LINE3, iDurchschnitt);

	//Kalibrierung abgeschlossen, Linienkante finden
	TextOut(4,LCD_LINE3, "KALIBRIERUNG ABGESCHLOSSEN");
	while (Sensor(IN_3) > iDurchschnitt) {
		OnFwd(OUT_B, 50);
		OnRev(OUT_A, 50);
	}
	Off(OUT_AB);
	return iDurchschnitt;
}

long kalibrierung90()
	//Funktion zur Ermittlung der Zeit,
	//die für eine 90Grad-Drehung benötigt wird
{
	ClearScreen();
	TextOut(5,LCD_LINE1, "KALIBR. LÄUFT");
	int iHelligkeitkal=0;
	long t0kal=CurrentTick(), turntime180=0;

	//drehen bis Linie wieder gefunden ist
  OnFwd(OUT_A,POWER);
	OnRev(OUT_B,POWER);
	Wait(300);
  do{
	iHelligkeitkal=Sensor(IN_3);
	}while(iHelligkeitkal>=50)

	TextOut(5,LCD_LINE2, "LINIE GEFUNDEN");


	//Benötigte Zeit für die 180Grad Drehung berechnen
	turntime180=CurrentTick()-t0kal;

	//zurückdrehen auf die Linie
  OnFwd(OUT_B,POWER);
	OnRev(OUT_A,POWER);
	Wait(300);
  do{
	iHelligkeitkal=Sensor(IN_3);
	}while(iHelligkeitkal>=50)
	TextOut(5,LCD_LINE3, "KALIBR. ABGESCHLOSSEN");
	return turntime180/2;
}
