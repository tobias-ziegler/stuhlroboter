#define POWER 30

void sensorenInitialisieren();
void startVorgang();
void bedienungsanleitungAnzeigen();
void aufTastendruckWarten();
void Drive(int time);
void DriveToLineEnd(int LineColor);
void turnToColor(int LineColor, int color, int timeTurn90);
void turn(int color, int timeTurn90);
int kalibrierungSW();
long kalibrierung90();

task main() {

	sensorenInitialisieren();
 
	 int color = Sensor(IN_1);
     int timeTurn90 = kalibrierung90();
     Drive(100);
     int LineColor = kalibrierungSW();
     
     //Linienende
     DriveToLineEnd(LineColor);
     //Vorfahren zur Mitte
     Drive(1200);
     //Zur Farbe drehen
     turnToColor(LineColor, color, timeTurn90);
     //Liniefahren
     DriveToLineEnd(LineColor);
     turn(color, timeTurn90);
     DriveToLineEnd(LineColor);

}

void sensorenInitialisieren() {
	SetSensorColorFull(IN_1);
	SetSensorLowspeed(IN_2);
	SetSensorLight(IN_3);
	SetSensorTouch(IN_4);
}

void startVorgang() {
	bedienungsanleitungAnzeigen();
	aufTastendruckWarten();
	//Konsole löschen
	ClearScreen();
	//Ton ausgeben
	PlaySound(SOUND_DOUBLE_BEEP);
}

void bedienungsanleitungAnzeigen() {
	TextOut(5, LCD_LINE1, "Drücken Sie den Knopf, um den Sortiervorgang zu starten.");
}

void aufTastendruckWarten() {
	while(true) {
		if(Sensor(IN_4) == 1) {
			break;
		}
	}
}

void Drive(int time)
{
 OnFwd(OUT_AB, POWER);
 Wait(time);
 Off(OUT_AB);
}

void DriveToLineEnd(int LineColor)
{
     //Gerade ausfahren bis Linienende
     while(1)
     {
             if(Sensor(IN_3)  <= LineColor)
             {
              OnFwd(OUT_A,POWER);
    	        OnFwd(OUT_B,POWER) ;
    	       }
    	       else
            {
                 //Links
                  OnFwd(OUT_B,POWER);
	                OnRev(OUT_A,POWER);
	                Wait(120);
                  Off(OUT_AB);
	                //Überprüfung
	                if(Sensor(IN_3) > LineColor)
                  {
                           //Rechts
                           OnFwd(OUT_A,POWER);
	                         OnRev(OUT_B,POWER);
	                         Wait(240);
	                         Off(OUT_AB);
                           if(Sensor(IN_3) > LineColor) {
                                //Links
                                OnFwd(OUT_B,POWER);
	                              OnRev(OUT_A,POWER);
	                              Wait(120);
	                              Off(OUT_AB);
	                              break;
                           }
   	              }
            }
     }
}

void turnToColor(int LineColor, int color, int timeTurn90) {
     switch(color) {
         //Schwarz
         case 1: {
             //Rechtsdrehung
             OnFwd(OUT_A,POWER);
             OnRev(OUT_B,POWER);
             Wait(timeTurn90);
             Off(OUT_AB);
         }
     }
}

void turn(int color, int timeTurn90) {
    switch(color) {
        case 1: {
             Drive(400);
             //Linksdrehung
             OnFwd(OUT_B,POWER);
             OnRev(OUT_A,POWER);
             Wait(timeTurn90);
             Off(OUT_AB);
        }
    }
}

int kalibrierungSW(void)
	//Funktion zur Ermittlung des Schwarzwertes
	//der Linienkante durch Berechnung des Durch-
	//schnittes aus Minimal-(schwarz) und Maximalwert(weiß)
	//Funktion hat eigene "POWER" (=50)
	//die auf "Dreh-Zeit" (600/1200) abgestimmt ist.
{
	long end_time;
	long t0 = CurrentTick();
	int iDurchschnitt;
	int imin = 999;
	int imax = -1;
	int iHelligkeitKal=0;
	ClearScreen();
	// Kalibrierung nach links
	TextOut(5,LCD_LINE1, "KALIBRIERUNG LINKS");
  //Motor nach links starten
	OnFwd(OUT_B, 50);
	OnRev(OUT_A, 50);
	while (CurrentTick()-t0 < 990) {
		iHelligkeitKal = Sensor(IN_3);
		if (iHelligkeitKal > imax) {
			imax = iHelligkeitKal;
		} else if (iHelligkeitKal < imin) {
			imin = iHelligkeitKal;
		}
	}
	// Kalibrierung nach rechts
	TextOut(5,LCD_LINE2, "KALIBRIERUNG RECHTS");
	end_time = CurrentTick() + 1200;
	OnFwd(OUT_A, 50);
	OnRev(OUT_B, 50);
	while (CurrentTick() < end_time) {
		iHelligkeitKal = Sensor(IN_3);
		if (iHelligkeitKal > imax) {
			imax = iHelligkeitKal;
		} else if (iHelligkeitKal < imin) {
			imin = iHelligkeitKal;
		}
	}

	//Durchschnitt ausrechnen und anzeigen
	iDurchschnitt = (imin+imax)/2;
	ClearLine(LCD_LINE3);
	TextOut(4,LCD_LINE3, "SW Linienkante:");
	NumOut(65, LCD_LINE3, iDurchschnitt);

	//Kalibrierung abgeschlossen, Linienkante finden
	TextOut(4,LCD_LINE3, "KALIBRIERUNG ABGESCHLOSSEN");
	while (Sensor(IN_3) > iDurchschnitt) {
		OnFwd(OUT_B, 50);
		OnRev(OUT_A, 50);
	}
	Off(OUT_AB);
	return iDurchschnitt;
}

long kalibrierung90()
	//Funktion zur Ermittlung der Zeit,
	//die für eine 90Grad-Drehung benötigt wird
{
	ClearScreen();
	TextOut(5,LCD_LINE1, "KALIBR. LÄUFT");
	int iHelligkeitkal=0;
	long t0kal=CurrentTick(), turntime180=0;

	//drehen bis Linie wieder gefunden ist
  OnFwd(OUT_A,POWER);
	OnRev(OUT_B,POWER);
	Wait(300);
  do{
	iHelligkeitkal=Sensor(IN_3);
	}while(iHelligkeitkal>=50)

	TextOut(5,LCD_LINE2, "LINIE GEFUNDEN");


	//Benötigte Zeit für die 180Grad Drehung berechnen
	turntime180=CurrentTick()-t0kal;

	//zurückdrehen auf die Linie
  OnFwd(OUT_B,POWER);
	OnRev(OUT_A,POWER);
	Wait(300);
  do{
	iHelligkeitkal=Sensor(IN_3);
	}while(iHelligkeitkal>=50)
	TextOut(5,LCD_LINE3, "KALIBR. ABGESCHLOSSEN");
	return turntime180/2;
}
