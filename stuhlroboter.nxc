#define POWER 30
#define LINIENVERFOLGUNG_DREHUNG_LINKS 120
#define LINIENVERFOLGUNG_DREHUNG_RECHTS 240

void sensorenInitialisieren();
void startVorgang();
void bedienungsanleitungAnzeigen();
void aufTastendruckWarten();
void sortierVorgang(int linienFarbton, int stuhlFarbe, int zeitFuer90GradDrehung);
void linienVerfolgung(int linienFarbton);
void linksDrehung(int zeitspanne);
void rechtsDrehung(int zeitspanne);
void geradeAusFahren(int zeitspanne);
void zuFarbeFahren(int linienFarbton, int stuhlFarbe, int zeitFuer90GradDrehung);
void zuStartpunktFahren(int linienFarbton, int stuhlFarbe, int zeitFuer90GradDrehung);
boolean istObjektImWeg();
int kalibrierungSW();
long kalibrierung90();

//TODO: Remove magic numbers
//TODO: Check comments
task main() {

	int zeitFuer90GradDrehung;
	int linienFarbton;
	int stuhlFarbe;

	//Kalibrierung
	zeitFuer90GradDrehung = kalibrierung90();
	//geradeAusFahren(100);
	linienFarbton = kalibrierungSW();

	//Start
	sensorenInitialisieren();
	startVorgang();
	//Farbe einlesen
	//TODO: Add color validity check
	//TODO: Wait for correct color input???
	stuhlFarbe = Sensor(IN_1);
	//2 Sekunden warten
	Wait(2000);

	sortierVorgang(linienFarbton, stuhlFarbe, zeitFuer90GradDrehung);
}

void sensorenInitialisieren() {
	SetSensorColorFull(IN_1);
	SetSensorLowspeed(IN_2);
	SetSensorLight(IN_3);
	SetSensorTouch(IN_4);
}

void startVorgang() {
	bedienungsanleitungAnzeigen();
	aufTastendruckWarten();
	//Konsole löschen
	ClearScreen();
	//Ton ausgeben
	PlaySound(SOUND_DOUBLE_BEEP);
}

void bedienungsanleitungAnzeigen() {
	TextOut(5, LCD_LINE1, "Drücken Sie den Knopf, um den Sortiervorgang zu starten.");
}

void aufTastendruckWarten() {
	while(true) {
		if(Sensor(IN_4) == 1) {
			break;
		}
	}
}

//TODO: Stop on contact and display error
void sortierVorgang(int linienFarbton, int stuhlFarbe, int zeitFuer90GradDrehung) {
    while(true) {
		//Zur Farbe fahren
		zuFarbeFahren(linienFarbton, stuhlFarbe, zeitFuer90GradDrehung);

		//180° Drehung
		rechtsDrehung(zeitFuer90GradDrehung * 2);

		//Zurückfahren
		zuStartpunktFahren(linienFarbton, stuhlFarbe, zeitFuer90GradDrehung);

		//180° Drehung
		rechtsDrehung(zeitFuer90GradDrehung * 2);
	}
}

void linienVerfolgung(int linienFarbton) {
	while(true) {
		//Roboter befindet sich auf der Linie, geradeaus fahren
		if(Sensor(IN_3) <= linienFarbton) {
			OnFwd(OUT_AB, POWER);
			continue;
		}

		//Überprüfung, ob sich die Linie links befindet
		linksDrehung(LINIENVERFOLGUNG_DREHUNG_LINKS);
		if(Sensor(IN_3) <= linienFarbton) {
			continue;
		}

		//Überprüfung, ob sich die Linie rechts befindet
		rechtsDrehung(LINIENVERFOLGUNG_DREHUNG_RECHTS);
		if(Sensor(IN_3) <= linienFarbton) {
			continue;
		}

		//Auf Startpunkt zurückdrehen, Linienverfolgung abgeschlossen
		linksDrehung(LINIENVERFOLGUNG_DREHUNG_LINKS);
		break;
	}
}

void linksDrehung(int zeitspanne) {
	OnFwd(OUT_B,POWER);
	OnRev(OUT_A,POWER);
	Wait(zeitspanne);
	Off(OUT_AB);
}

void rechtsDrehung(int zeitspanne) {
	OnFwd(OUT_A,POWER);
	OnRev(OUT_B,POWER);
	Wait(zeitspanne);
	Off(OUT_AB);
}

void geradeAusFahren(int zeitspanne) {
	OnFwd(OUT_AB, POWER);
	Wait(zeitspanne);
	Off(OUT_AB);
}

void zuFarbeFahren(int linienFarbton, int stuhlFarbe, int zeitFuer90GradDrehung) {
	switch(stuhlFarbe) {
		case INPUT_BLACKCOLOR:
			linienVerfolgung(linienFarbton);
			//Vorfahren zur Mitte
			geradeAusFahren(1200);
			rechtsDrehung(zeitFuer90GradDrehung);
   			linienVerfolgung(linienFarbton);
			geradeAusFahren(400);
			linksDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			break;
		case INPUT_REDCOLOR:
			linienVerfolgung(linienFarbton);
			//Vorfahren zur Mitte
			geradeAusFahren(1200);
			linksDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			geradeAusFahren(400);
			rechtsDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			break;
		case INPUT_YELLOWCOLOR:
			linienVerfolgung(linienFarbton);
			//Vorfahren zur Mitte
			geradeAusFahren(1200);
			linienVerfolgung(linienFarbton);
			break;
	}
}

void zuStartpunktFahren(int linienFarbton, int stuhlFarbe, int zeitFuer90GradDrehung) {
	switch(stuhlFarbe) {
		case INPUT_BLACKCOLOR:
			linienVerfolgung(linienFarbton);
			geradeAusFahren(400);
			rechtsDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			//Vorfahren zur Mitte
			geradeAusFahren(1200);
			linksDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			break;
		case INPUT_REDCOLOR:
			linienVerfolgung(linienFarbton);
			geradeAusFahren(400);
			linksDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			//Vorfahren zur Mitte
			geradeAusFahren(1200);
			rechtsDrehung(zeitFuer90GradDrehung);
			linienVerfolgung(linienFarbton);
			break;
		case INPUT_YELLOWCOLOR:
			linienVerfolgung(linienFarbton);
			//Vorfahren zur Mitte
			geradeAusFahren(1200);
			linienVerfolgung(linienFarbton);
			break;
	}
}

boolean istObjektImWeg() {
	return SensorUS(IN_2) < 50;
}

int kalibrierungSW(void)
	//Funktion zur Ermittlung des Schwarzwertes
	//der Linienkante durch Berechnung des Durch-
	//schnittes aus Minimal-(schwarz) und Maximalwert(weiß)
	//Funktion hat eigene "POWER" (=50)
	//die auf "Dreh-Zeit" (600/1200) abgestimmt ist.
{
	long end_time;
	long t0 = CurrentTick();
	int iDurchschnitt;
	int imin = 999;
	int imax = -1;
	int iHelligkeitKal=0;
	ClearScreen();
	// Kalibrierung nach links
	TextOut(5,LCD_LINE1, "KALIBRIERUNG LINKS");
  //Motor nach links starten
	OnFwd(OUT_B, 50);
	OnRev(OUT_A, 50);
	while (CurrentTick()-t0 < 990) {
		iHelligkeitKal = Sensor(IN_3);
		if (iHelligkeitKal > imax) {
			imax = iHelligkeitKal;
		} else if (iHelligkeitKal < imin) {
			imin = iHelligkeitKal;
		}
	}
	// Kalibrierung nach rechts
	TextOut(5,LCD_LINE2, "KALIBRIERUNG RECHTS");
	end_time = CurrentTick() + 1200;
	OnFwd(OUT_A, 50);
	OnRev(OUT_B, 50);
	while (CurrentTick() < end_time) {
		iHelligkeitKal = Sensor(IN_3);
		if (iHelligkeitKal > imax) {
			imax = iHelligkeitKal;
		} else if (iHelligkeitKal < imin) {
			imin = iHelligkeitKal;
		}
	}

	//Durchschnitt ausrechnen und anzeigen
	iDurchschnitt = (imin+imax)/2;
	ClearLine(LCD_LINE3);
	TextOut(4,LCD_LINE3, "SW Linienkante:");
	NumOut(65, LCD_LINE3, iDurchschnitt);

	//Kalibrierung abgeschlossen, Linienkante finden
	TextOut(4,LCD_LINE3, "KALIBRIERUNG ABGESCHLOSSEN");
	while (Sensor(IN_3) > iDurchschnitt) {
		OnFwd(OUT_B, 50);
		OnRev(OUT_A, 50);
	}
	Off(OUT_AB);
	return iDurchschnitt;
}

long kalibrierung90()
	//Funktion zur Ermittlung der Zeit,
	//die für eine 90Grad-Drehung benötigt wird
{
	ClearScreen();
	TextOut(5,LCD_LINE1, "KALIBR. LÄUFT");
	int iHelligkeitkal=0;
	long t0kal=CurrentTick(), turntime180=0;

	//drehen bis Linie wieder gefunden ist
  OnFwd(OUT_A,POWER);
	OnRev(OUT_B,POWER);
	Wait(300);
  do{
	iHelligkeitkal=Sensor(IN_3);
	}while(iHelligkeitkal>=50)

	TextOut(5,LCD_LINE2, "LINIE GEFUNDEN");


	//Benötigte Zeit für die 180Grad Drehung berechnen
	turntime180=CurrentTick()-t0kal;

	//zurückdrehen auf die Linie
  OnFwd(OUT_B,POWER);
	OnRev(OUT_A,POWER);
	Wait(300);
  do{
	iHelligkeitkal=Sensor(IN_3);
	}while(iHelligkeitkal>=50)
	TextOut(5,LCD_LINE3, "KALIBR. ABGESCHLOSSEN");
	return turntime180/2;
}
